# Infrastructure

    docker-compose up

# Build

    go build -o ./bin/smartbrainsvc ./main.go 

# Run

    ./bin/smartbrainsvc
    export USE_HTTP=true && ./bin/smartbrainsvc # запуск с http сервером

# Http
    
    curl --location --request POST 'localhost:8080/new-tracker' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --data-urlencode 'period=15s' \
    --data-urlencode 'frequency=1s'

    curl --location --request GET 'localhost:8080/get-result?id=240d13a7-943a-40e6-af57-4ef11738a957'

# Description

Бизнес потребность понимаю как отслеживание курса прямо сейчас, 
поэтому в отсутсвие обработчиков, срок жизни задачи на мониторинг никак не продлевается.

Попросили в 15:00:00 отслеживать 10 минут с частотой 1 минута. Значит время жизни мониторинга до 15:10:00.
Если всё лежало с 15:05:01 то будт доступны 6 значений которые получили пока сервис работал.

Ограничения:
- Frequency от 1 секунды до часу
- Period от 2 секунд до часу 

Проблему того, что если сервис не читает из очереди, там копятся сообщения, как-то отдельно не решала. Можно
- Писать сообщения в очередь с ttl (x-message-ttl например час, с учётом ограничения на period)
- Накапливать сообщения в очереди и как только появится обработчик, вычитывать их с какой-то дешёвой обработкой (как сейчас)

Сделала допущение, что результаты мониторинга могут не храниться постоянно, поэтому выбрала Redis.

Выбрала RabbitMQ, как самый подходящий вариант для распределения работы.

У сервиса есть ограничение по количеству одновременных процессов мониторинга, для экспериментов захардкожено в коде 2.

### Что не делала, из-за того что времени на пролноценное продовоустойчивое) решение трубуется больше чем пара дней

Не добавляла логику с конфигами, всё захардкодила в main. Кроме флажка запуска http сервера (USE_HTTP), 
что бы можно было запустить несколько экземпляров сервиса не меняя код.

Не использовала каких-то фреймворков для API, ифами завалидировала параметры. Наверняка есть решения поизящнее.

bitcoin сервис: 
Для сетевых походов в сторонние сервисы я бы в общем случае добавила какие-то разумные для этого внешнего сервиса таймауты.
В зависимости от бизнес логики прикрутила бы какой-то fallback 
запрос данных у другого провайдера этих данных / предыдущее значение курса из кэша

Если сервис может подолгу лежать, обернула бы в circuit breaker,
что бы в случае проблем, не ждать всё время, отведённое на запрос для каждого похода.

Если внешний сервис отвечает долго то возможны сайдэффекты из-за того,
что у меня минимальная частота опроса сервиса 1 секунда, а хожу за значением я синхронно в потоке воркера.
Можно было бы ходить асинхронно, но тогда надо написать ещё логику синхронизации завершения мониоринга и получения результата.

Так как все воркеры по сути делают одно и тоже ходят по сети за одними и теми же данными, 
в общем случае я бы кэшила тут локально (прям в памяти сервиса, что бы доставать очень дёшево). Но это же деньги.
Я не смогла нагуглить, как часто на бирже меняется курс 
и существует ли хоть какой-то разумный интервал когда можно считать что данные не успели измениться. 
При большой нагрузке, воркеры могут одновременно запрашивать текущий курс и
если по бизнесу это допустимо, добавила бы локальный кэш в сервисе хотя бы на 10ms, всё дешевле чем поход по сети.

Не добавляла метрики и мониторинги для сервиса

Не писала тесты ))
